OpenAI Codex v0.72.0 (research preview)
--------
workdir: /home/cc/tmp/anvil
model: gpt-5.1-codex-max
provider: openai
approval: never
sandbox: danger-full-access
reasoning effort: none
reasoning summaries: auto
session id: 019b1e47-ab97-7713-856b-2239610f8ba3
--------
user
Please take a careful look at the current hardware and repo, and create a new Dockerfile named codex.dockerfile at the root of this repo that, when built, puts me in a /bin/bash CLI setting at the root of the repository, with the repository installed.
mcp startup: no servers
exec
/bin/bash -lc 'cd /home/cc/tmp/anvil && ls' in /home/cc/tmp/anvil succeeded in 21ms:
CODE_OF_CONDUCT.md
CONTRIBUTING_DCO.md
Cargo.toml
LICENSE
NOTICE
README.md
build.md
build.sh
deploy
deploy.sh
discussion
doc
docker
e2e
local-test.sh
reproduce-verification-result.sh
rust-toolchain.toml
src
tools
traj.txt

thinking
**Checking for existing Dockerfile**
exec
/bin/bash -lc 'cd /home/cc/tmp/anvil && ls docker' in /home/cc/tmp/anvil succeeded in 21ms:
controller
exec
/bin/bash -lc 'cd /home/cc/tmp/anvil && ls docker/controller' in /home/cc/tmp/anvil succeeded in 21ms:
Dockerfile.local
Dockerfile.publish

thinking
**Identifying project type**

I'm checking Cargo files to confirm this is a Rust project and will review the README for installation instructions to create a Dockerfile at the root.
exec
/bin/bash -lc 'cd /home/cc/tmp/anvil && head -n 40 README.md' in /home/cc/tmp/anvil succeeded in 20ms:
[![License](https://img.shields.io/badge/License-MIT-green.svg)](https://github.com/anvil-verifier/anvil/blob/main/LICENSE)
[![CI](https://github.com/anvil-verifier/anvil/actions/workflows/ci.yml/badge.svg)](https://github.com/anvil-verifier/anvil/actions/workflows/ci.yml)

# Anvil: Building Formally Verified Kubernetes Controllers

Anvil is a framework for building and formally verifying Kubernetes controllers. Developers use Anvil to implement Kubernetes controllers in Rust, specify correctness properties in a formal language, and verify that the controller implementations satisfy the correctness properties with machine-checkable proofs. Anvil is built on top of [Verus](https://github.com/verus-lang/verus), a tool for verifying Rust programs, and [kube](https://github.com/kube-rs/kube), a Kubernetes client in Rust.

So far, we have built and verified three Kubernetes controllers (for managing ZooKeeper, RabbitMQ and FluentBit) using Anvil. We used the [Pravega ZooKeeper operator](https://github.com/pravega/zookeeper-operator), [official RabbitMQ operator](https://github.com/rabbitmq/cluster-operator) and [official Fluent operator](https://github.com/fluent/fluent-operator) as references when building our controllers. We are now using Anvil to build (and verify) more controllers, including Kubernetes built-in controllers.

For now, the best way to use Anvil is to download the source code and import its components into your controller projects, like what we did for our controller [examples](src/controllers/). To use Anvil, you will need to install [Verus](https://github.com/verus-lang/verus) (See the [installation instructions](https://github.com/verus-lang/verus/blob/main/INSTALL.md)). Currently Anvil uses Verus version `release/rolling/0.2025.11.30.840fa61` with pre-built [binary](https://github.com/verus-lang/verus/releases/tag/release%2F0.2025.11.30.840fa61) available.

If you want to reproduce the results in the OSDI'24 paper "Anvil: Verifying Liveness of Cluster Management Controllers", please refer to the [osdi24](https://github.com/anvil-verifier/anvil/tree/osdi24) branch.

## Implementing controllers with Anvil

Implementing a Kubernetes controller in Anvil mostly means implementing a `reconcile()` function for a particular custom resource type (which is no different from the traditional way of implementing controllers). The only major difference is that one has to write `reconcile()` as a state machine that defines initial state, ending state and state transitions. The reason for this style is to enable formal verification. Anvil provides an [API](src/reconciler/exec/reconciler.rs) for developers to implement their `reconcile()` in this way:
```rust
// Anvil's interface for implementing reconcile() as a state machine
pub trait Reconciler{
    type R; // custom resource type

thinking
**Checking for build instructions**

I'm looking for build scripts or documentation like build.md or Dockerfile to understand installation and build steps.
exec
/bin/bash -lc "cd /home/cc/tmp/anvil && sed -n '1,200p' build.md" in /home/cc/tmp/anvil succeeded in 21ms:
# How to build, verify and run controller

## Code Structure

```shell
.
├── build.sh # build controller only
├── deploy
│   └── <controller_name>
│       └── <configuration files>
├── deploy.sh # subscript for e2e test
├── docker
│   └── controller
│       └── Dockerfile
├── e2e
│   └── src
├── local-test.sh # build and perform e2e test
├── src
│   └── <controller_name>_controller.rs
├──...

thinking
**Checking Rust setup**

I'm verifying if Rust is required by inspecting the rust-toolchain.toml to guide Dockerfile environment setup.
exec
/bin/bash -lc 'cd /home/cc/tmp/anvil && cat rust-toolchain.toml' in /home/cc/tmp/anvil succeeded in 21ms:
# this should be synchronized with the Verus version, since we need to combine
# k8s compiled with rustc and our own code compiled with rust-verify.sh
[toolchain]
channel = "1.91.0"

thinking
**Assessing Dockerfile requirements**

I'm clarifying that the Dockerfile must be named codex.dockerfile at the root, base on Rust with needed tools, set the working directory to root, install build dependencies (possibly including Rust, cargo, Go, kind), and finalize with a /bin/bash CLI prompt; next I'll check existing Dockerfiles like docker/controller/Dockerfile.local for guidance.
exec
/bin/bash -lc "cd /home/cc/tmp/anvil && sed -n '1,200p' docker/controller/Dockerfile.local" in /home/cc/tmp/anvil succeeded in 22ms:
# keep consistent with CI env
FROM ubuntu:22.04

ARG APP

COPY src/${APP}_controller /usr/local/bin/controller

ENTRYPOINT ["/usr/local/bin/controller", "run"]

thinking
**Planning repo environment setup**

I'm considering building a Dockerfile that copies the repo into a container, sets up a working directory, and installs Rust 1.91 toolchain plus essential dependencies for building, guided by indications from the repository's CI workflows. Next, I'll check for any .github workflows to confirm dependencies and build steps.
exec
/bin/bash -lc 'cd /home/cc/tmp/anvil && ls -a' in /home/cc/tmp/anvil succeeded in 22ms:
.
..
.git
.github
.gitignore
CODE_OF_CONDUCT.md
CONTRIBUTING_DCO.md
Cargo.toml
LICENSE
NOTICE
README.md
build.md
build.sh
deploy
deploy.sh
discussion
doc
docker
e2e
local-test.sh

thinking
**Checking CI workflows and dependencies**

I'm planning to review the `.github/workflows` directory to discover any continuous integration setups and gather instructions on dependencies required for the project.
exec
/bin/bash -lc 'cd /home/cc/tmp/anvil && ls .github/workflows' in /home/cc/tmp/anvil succeeded in 21ms:
ae.yml
ci.yml
controller-build.yml
package-deletion.yml
verus-build.yml
exec
/bin/bash -lc "cd /home/cc/tmp/anvil && sed -n '1,200p' .github/workflows/ci.yml" in /home/cc/tmp/anvil succeeded in 22ms:
name: Continuous integration
run-name: Continuous integration run by ${{ github.actor }}
on:
  # push:
  #   branches:
  #     - main
  #   paths-ignore:
  #     - "README.md"
  #     - ".gitignore"
  #     - "doc/**"
  pull_request:
  merge_group:
  workflow_dispatch:
env:
  verus_release: 0.2025.11.30.840fa61
  kind_version: 0.23.0
  go_version: "^1.20"
  home_dir: /home/runner

jobs:
exec
/bin/bash -lc "cd /home/cc/tmp/anvil && sed -n '200,400p' .github/workflows/ci.yml" in /home/cc/tmp/anvil succeeded in 21ms:
      - name: Restore Verus cache
        uses: actions/cache@v4
        with:
          path: |
            ${{ env.home_dir }}/verus
            ${{ env.home_dir }}/.cargo
            ${{ env.home_dir }}/.rustup
          key: verus-${{ runner.os }}-${{ env.verus_release }}-${{ hashFiles('rust-toolchain.toml') }}
      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.go_version }}
      - name: Install kind
        run: go install sigs.k8s.io/kind@v$kind_version
      - name: Deploy vdeployment admission controller
        run: |
          export PATH="$PATH:$HOME/verus"
          ./local-test.sh vdeployment-admission --build
      - name: Run vdeployment e2e tests for admission
        run: . "$HOME/.cargo/env" && cd e2e && cargo run -- vdeployment-admission

thinking
**Planning Dockerfile with hardware detection**

I'm noting the need to inspect hardware architecture (e.g., via `uname -m`) to select an appropriate base image for the Dockerfile, ensuring the environment matches the repo requirements and allows a CLI at root with the repo installed.
exec
/bin/bash -lc 'uname -a' in /home/cc/tmp/anvil succeeded in 20ms:
Linux eamin 5.4.0-198-generic #218-Ubuntu SMP Fri Sep 27 20:18:53 UTC 2024 x86_64 x86_64 x86_64 GNU/Linux

thinking
**Reviewing environment setup approach**

I'm considering whether to create a plan before proceeding and will examine existing workflows and build scripts to understand required dependencies and environment setup for the Dockerfile.
exec
/bin/bash -lc "cd /home/cc/tmp/anvil && sed -n '1,200p' build.sh" in /home/cc/tmp/anvil succeeded in 22ms:
#!/usr/bin/env bash

set -eu

# script dir is root of repo
DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" >/dev/null 2>&1 && pwd)"
cd "$DIR/src"

cd deps_hack
cargo build
cd ..
# TODO: after the lifetime check is fixed in verus, remove the --no-lifetime flag
verus -L dependency=deps_hack/target/debug/deps \
  --extern=deps_hack="deps_hack/target/debug/libdeps_hack.rlib" \
  --compile \
  "$@"

thinking
**Mapping Docker dependencies and setup**

I cataloged key dependencies (Rust toolchain 1.91, Verus release, Go 1.20.14) and apt packages (build-essential, curl, git, pkg-config, libssl-dev, clang, lld) needed for building and verifying, deciding to base the image on Ubuntu 22.04 and copy the repo into /anvil with PATH adjustments and optional environment variables for Verus; next I'll confirm precise system libs from Cargo.toml and finalize install steps.
exec
/bin/bash -lc "cd /home/cc/tmp/anvil && sed -n '1,120p' Cargo.toml" in /home/cc/tmp/anvil succeeded in 22ms:
[package]
name = "verifiable-controllers"
version = "0.1.0"
edition = "2021"

[dependencies]
vstd = { path = "../verus/source/vstd" }
deps_hack = { path = "src/deps_hack" }
tungstenite = "0.20.1"
rand = "0.8"

thinking
**Checking environment variable usage**

I’m verifying if the repo expects an environment variable like VERUS_DIR to locate the verus library by searching references to VERUS_DIR across files.
exec
/bin/bash -lc 'cd /home/cc/tmp/anvil && rg "VERUS"' in /home/cc/tmp/anvil succeeded in 36ms:
traj.txt:I’m verifying if the repo expects an environment variable like VERUS_DIR to locate the verus library by searching references to VERUS_DIR across files.
traj.txt:/bin/bash -lc 'cd /home/cc/tmp/anvil && rg "VERUS"' in /home/cc/tmp/anvil
build.md:	--build:		Call ./build.sh to build the controller before test, should have VERUS_DIR speccified
docker/controller/Dockerfile.publish:ARG VERUS_VER
docker/controller/Dockerfile.publish:RUN wget -q "https://github.com/verus-lang/verus/releases/download/release%2F${VERUS_VER}/verus-${VERUS_VER}-x86-linux.zip"
docker/controller/Dockerfile.publish:RUN unzip "verus-${VERUS_VER}-x86-linux.zip"
tools/gen-t1.py:        "python3 count-anvil-loc.py $VERUS_DIR/source/tools/line_count/anvil_loc_table"
tools/gen-t1.py:        "python3 count-loc.py $VERUS_DIR/source/tools/line_count/{}_loc_table {}".format(
reproduce-verification-result.sh:pushd $VERUS_DIR/source/tools/line_count

thinking
**Preparing to check Docker publish**

I'm planning to open the Docker publish files to look for useful hints related to the earlier traj file.
exec
/bin/bash -lc "cd /home/cc/tmp/anvil && sed -n '1,200p' docker/controller/Dockerfile.publish" in /home/cc/tmp/anvil succeeded in 21ms:
FROM ubuntu:22.04 AS builder

ARG VERUS_VER
ARG APP
WORKDIR /

SHELL ["/bin/bash", "-c"]

RUN mkdir /anvil
COPY . /anvil
RUN apt-get update && apt-get install -y gcc wget unzip curl pkg-config libssl-dev

# install Verus
RUN wget -q "https://github.com/verus-lang/verus/releases/download/release%2F${VERUS_VER}/verus-${VERUS_VER}-x86-linux.zip"
RUN unzip "verus-${VERUS_VER}-x86-linux.zip"
ENV PATH="${PATH}:/verus-x86-linux"

# install Rust
RUN curl --proto '=https' --tlsv1.2 --retry 10 --retry-connrefused -fsSL "https://sh.rustup.rs" | sh -s -- --default-toolchain none -y


thinking
**Planning interactive Docker image**

I'm outlining a single-stage Ubuntu 22.04 Docker image installing Rust (fixed toolchain), Verus (release zipped archive in /opt/verus), essential apt packages, Go 1.20.14 with PATH and GOPATH, and optionally kind via `go install`. Default command will be `/bin/bash` to support an interactive shell with repo and environment ready.

thinking
**Confirming Verus path setup and cargo dependency caching**

The repo's Cargo.toml expects a relative ../verus directory for `vstd`, so I'll create a symlink `/verus` pointing to `/opt/verus` to satisfy that path when building in `/anvil`. After linking, I'll run `cargo fetch` to cache dependencies and `cargo build -p deps_hack` to ensure required crates and standards are installed.

thinking
**Drafting Dockerfile with version args**

I'm designing a Dockerfile based on Ubuntu 22.04 that installs Rust, Go, and Verus using ARGs for customizable versions, sets environment variables including PATH to include Verus, and prepares the workspace under /anvil with Cargo dependencies preloaded.

thinking
**Clarifying Docker environment setup**

I'm aligning environment variables and shell settings to ensure the container defaults to a bash CLI at the repo root, managing PATH and rust toolchain availability properly, and planning to clean apt lists to keep image size minimal.

thinking
**Refining Docker environment variables and paths**

Analyzed needed environment variables and PATH order, deciding to set GOPATH before updating PATH to include its bin, alongside Go and Rust cargo paths; also planning WORKDIR placement before copying files for correct context. Noted `cargo fetch` requires dependencies like `Cargo.toml` present and may need a symlink to `vstd` before fetching.

thinking
**Confirming build environment details and patch approach**

Noting that the `/verus` symlink is absolute and present for `cargo fetch` via the `../verus` path, which should succeed since the release includes the necessary source directories. Decided to include `git` via apt for Go installs but no need for `openssh` or extra env vars. Planning to reduce image size with `rm -rf /var/lib/apt/lists/*` and to add a file via `apply_patch` after checking for existing codex.
file update
A /home/cc/tmp/anvil/codex.dockerfile
# Dev shell for Anvil (Rust + Verus + Go/kind-ready)
FROM ubuntu:22.04

ARG RUST_TOOLCHAIN=1.91.0
ARG VERUS_RELEASE=0.2025.11.30.840fa61
ARG GO_VERSION=1.20.14

ENV DEBIAN_FRONTEND=noninteractive \
    VERUS_DIR=/opt/verus \
    GOPATH=/go \
    PATH=/root/.cargo/bin:/usr/local/go/bin:/go/bin:/opt/verus:${PATH}

SHELL ["/bin/bash", "-c"]

# Base build tools and common dependencies
RUN apt-get update && apt-get install -y --no-install-recommends \
    build-essential curl git wget unzip pkg-config libssl-dev ca-certificates python3 \
 && rm -rf /var/lib/apt/lists/*

# Rust toolchain (matches rust-toolchain.toml)
RUN curl --proto '=https' --tlsv1.2 --retry 10 --retry-connrefused -fsSL "https://sh.rustup.rs" \
    | sh -s -- --default-toolchain none -y \
 && source "$HOME/.cargo/env" \
 && rustup toolchain install "${RUST_TOOLCHAIN}" \
 && rustup default "${RUST_TOOLCHAIN}"

# Go toolchain (for kind-based e2e flow)
RUN wget -q "https://go.dev/dl/go${GO_VERSION}.linux-amd64.tar.gz" \
 && rm -rf /usr/local/go \
 && tar -C /usr/local -xzf "go${GO_VERSION}.linux-amd64.tar.gz" \
 && rm "go${GO_VERSION}.linux-amd64.tar.gz" \
 && mkdir -p "${GOPATH}/bin"

# Verus release (matches CI)
RUN wget -q "https://github.com/verus-lang/verus/releases/download/release%2F${VERUS_RELEASE}/verus-${VERUS_RELEASE}-x86-linux.zip" \
 && unzip -q "verus-${VERUS_RELEASE}-x86-linux.zip" \
 && rm "verus-${VERUS_RELEASE}-x86-linux.zip" \
 && mv verus-x86-linux "${VERUS_DIR}" \
 && ln -s "${VERUS_DIR}" /verus

WORKDIR /anvil
COPY . /anvil

# Pre-fetch Cargo deps so the shell is ready to build
RUN source "$HOME/.cargo/env" && cargo fetch

CMD ["/bin/bash"]
apply_patch(auto_approved=true) exited 0 in 12ms:
Success. Updated the following files:
A codex.dockerfile
file update:
diff --git a/codex.dockerfile b/codex.dockerfile
new file mode 100644
index 0000000000000000000000000000000000000000..2ee831fbaa8a555db0da00344001cbac24036bec
--- /dev/null
+++ b/codex.dockerfile
@@ -0,0 +1,47 @@
+# Dev shell for Anvil (Rust + Verus + Go/kind-ready)
+FROM ubuntu:22.04
+
+ARG RUST_TOOLCHAIN=1.91.0
+ARG VERUS_RELEASE=0.2025.11.30.840fa61
+ARG GO_VERSION=1.20.14
+
+ENV DEBIAN_FRONTEND=noninteractive \
+    VERUS_DIR=/opt/verus \
+    GOPATH=/go \
+    PATH=/root/.cargo/bin:/usr/local/go/bin:/go/bin:/opt/verus:${PATH}
+
+SHELL ["/bin/bash", "-c"]
+
+# Base build tools and common dependencies
+RUN apt-get update && apt-get install -y --no-install-recommends \
+    build-essential curl git wget unzip pkg-config libssl-dev ca-certificates python3 \
+ && rm -rf /var/lib/apt/lists/*
+
+# Rust toolchain (matches rust-toolchain.toml)
+RUN curl --proto '=https' --tlsv1.2 --retry 10 --retry-connrefused -fsSL "https://sh.rustup.rs" \
+    | sh -s -- --default-toolchain none -y \
+ && source "$HOME/.cargo/env" \
+ && rustup toolchain install "${RUST_TOOLCHAIN}" \
+ && rustup default "${RUST_TOOLCHAIN}"
+
+# Go toolchain (for kind-based e2e flow)
+RUN wget -q "https://go.dev/dl/go${GO_VERSION}.linux-amd64.tar.gz" \
+ && rm -rf /usr/local/go \
+ && tar -C /usr/local -xzf "go${GO_VERSION}.linux-amd64.tar.gz" \
+ && rm "go${GO_VERSION}.linux-amd64.tar.gz" \
+ && mkdir -p "${GOPATH}/bin"
+
+# Verus release (matches CI)
+RUN wget -q "https://github.com/verus-lang/verus/releases/download/release%2F${VERUS_RELEASE}/verus-${VERUS_RELEASE}-x86-linux.zip" \
+ && unzip -q "verus-${VERUS_RELEASE}-x86-linux.zip" \
+ && rm "verus-${VERUS_RELEASE}-x86-linux.zip" \
+ && mv verus-x86-linux "${VERUS_DIR}" \
+ && ln -s "${VERUS_DIR}" /verus
+
+WORKDIR /anvil
+COPY . /anvil
+
+# Pre-fetch Cargo deps so the shell is ready to build
+RUN source "$HOME/.cargo/env" && cargo fetch
+
+CMD ["/bin/bash"]


thinking
**Summarizing final Dockerfile additions**

The new `codex.dockerfile` targets x86_64 architecture with Ubuntu 22.04, installs Rust 1.91.0, Go 1.20.14, and Verus 0.2025, and sets up the repo at `/anvil`. It prefetches Cargo dependencies and defaults to an interactive Bash shell. Next steps include building with `docker build -f codex.dockerfile -t anvil-dev .` and optionally running the container for dev work.
codex
- Added `codex.dockerfile` that builds on Ubuntu 22.04 (x86_64 host) with Rust 1.91.0, Go 1.20.14, and Verus release 0.2025.11.30.840fa61 installed and on `PATH`, plus build essentials/ssl/git tools.
- Verus is placed at `/opt/verus` with a `/verus` symlink to satisfy `vstd` path expectations; repo is copied to `/anvil`, Cargo deps are prefetched, `WORKDIR` is `/anvil`, and the default command drops into `/bin/bash`.

To build and drop into the shell: 
```
docker build -f codex.dockerfile -t anvil-dev .
docker run -it --rm anvil-dev
```
file update:
diff --git a/codex.dockerfile b/codex.dockerfile
new file mode 100644
index 0000000000000000000000000000000000000000..2ee831fbaa8a555db0da00344001cbac24036bec
--- /dev/null
+++ b/codex.dockerfile
@@ -0,0 +1,47 @@
+# Dev shell for Anvil (Rust + Verus + Go/kind-ready)
+FROM ubuntu:22.04
+
+ARG RUST_TOOLCHAIN=1.91.0
+ARG VERUS_RELEASE=0.2025.11.30.840fa61
+ARG GO_VERSION=1.20.14
+
+ENV DEBIAN_FRONTEND=noninteractive \
+    VERUS_DIR=/opt/verus \
+    GOPATH=/go \
+    PATH=/root/.cargo/bin:/usr/local/go/bin:/go/bin:/opt/verus:${PATH}
+
+SHELL ["/bin/bash", "-c"]
+
+# Base build tools and common dependencies
+RUN apt-get update && apt-get install -y --no-install-recommends \
+    build-essential curl git wget unzip pkg-config libssl-dev ca-certificates python3 \
+ && rm -rf /var/lib/apt/lists/*
+
+# Rust toolchain (matches rust-toolchain.toml)
+RUN curl --proto '=https' --tlsv1.2 --retry 10 --retry-connrefused -fsSL "https://sh.rustup.rs" \
+    | sh -s -- --default-toolchain none -y \
+ && source "$HOME/.cargo/env" \
+ && rustup toolchain install "${RUST_TOOLCHAIN}" \
+ && rustup default "${RUST_TOOLCHAIN}"
+
+# Go toolchain (for kind-based e2e flow)
+RUN wget -q "https://go.dev/dl/go${GO_VERSION}.linux-amd64.tar.gz" \
+ && rm -rf /usr/local/go \
+ && tar -C /usr/local -xzf "go${GO_VERSION}.linux-amd64.tar.gz" \
+ && rm "go${GO_VERSION}.linux-amd64.tar.gz" \
+ && mkdir -p "${GOPATH}/bin"
+
+# Verus release (matches CI)
+RUN wget -q "https://github.com/verus-lang/verus/releases/download/release%2F${VERUS_RELEASE}/verus-${VERUS_RELEASE}-x86-linux.zip" \
+ && unzip -q "verus-${VERUS_RELEASE}-x86-linux.zip" \
+ && rm "verus-${VERUS_RELEASE}-x86-linux.zip" \
+ && mv verus-x86-linux "${VERUS_DIR}" \
+ && ln -s "${VERUS_DIR}" /verus
+
+WORKDIR /anvil
+COPY . /anvil
+
+# Pre-fetch Cargo deps so the shell is ready to build
+RUN source "$HOME/.cargo/env" && cargo fetch
+
+CMD ["/bin/bash"]

tokens used
40,826
- Added `codex.dockerfile` that builds on Ubuntu 22.04 (x86_64 host) with Rust 1.91.0, Go 1.20.14, and Verus release 0.2025.11.30.840fa61 installed and on `PATH`, plus build essentials/ssl/git tools.
- Verus is placed at `/opt/verus` with a `/verus` symlink to satisfy `vstd` path expectations; repo is copied to `/anvil`, Cargo deps are prefetched, `WORKDIR` is `/anvil`, and the default command drops into `/bin/bash`.

To build and drop into the shell: 
```
docker build -f codex.dockerfile -t anvil-dev .
docker run -it --rm anvil-dev
```
